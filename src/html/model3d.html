<!doctype html>
<html lang="ru">
@include('modules/link.html',{ 'title': 'Main' })

<body>
	@include('modules/header.html',{'theme':'black'})
	<div id="viewer" style="width:100%; height:100vh;">
		<canvas id="scene"></canvas>
	</div>
	<script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
	<script src="https://unpkg.com/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>
	<script src="https://unpkg.com/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
	<script src="https://unpkg.com/three@0.140.0/examples/js/loaders/RGBELoader.js"></script>

	<style>
		#viewer {
			width: 100%;
			height: 100vh;
		}
	</style>



	<script>
		const container = document.getElementById('viewer');
		const canvas = document.getElementById('scene');

		// Сцена
		const scene = new THREE.Scene();

		// Камера
		const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
		camera.position.set(0, 0, 2);

		// Рендерер
		const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
		renderer.setSize(container.clientWidth, container.clientHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.outputEncoding = THREE.sRGBEncoding;

		// Контролы — только вращение, без зума
		const controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.enableZoom = false;
		controls.enablePan = false;
		controls.enableDamping = true;

		// HDRI
		const rgbeLoader = new THREE.RGBELoader();
		rgbeLoader.load('https://threejs.org/examples/textures/equirectangular/venice_sunset_1k.hdr', function (hdrEquirect) {
			const pmremGenerator = new THREE.PMREMGenerator(renderer);
			pmremGenerator.compileEquirectangularShader();
			const envMap = pmremGenerator.fromEquirectangular(hdrEquirect).texture;
			scene.environment = envMap;
			hdrEquirect.dispose();
			pmremGenerator.dispose();
		});

		// Свет
		const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
		directionalLight.position.set(5, 10, 7.5);
		scene.add(directionalLight);

		const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
		scene.add(ambientLight);

		// Загрузка модели
		const loader = new THREE.GLTFLoader();
		let watch = null;

		loader.load('/static/model/Venus_lowpoly.glb', function (gltf) {
			watch = gltf.scene;

			// Настройка металла и шероховатости
			watch.traverse((child) => {
				if (child.isMesh && child.material) {
					if (Array.isArray(child.material)) {
						child.material.forEach(m => { m.metalness = 1; m.roughness = 0.3; m.needsUpdate = true; });
					} else {
						child.material.metalness = 1;
						child.material.roughness = 0.3;
						child.material.needsUpdate = true;
					}
				}
			});

			// Центрируем и задаём фиксированный размер
			const box = new THREE.Box3().setFromObject(watch);
			const center = box.getCenter(new THREE.Vector3());
			const size = box.getSize(new THREE.Vector3());
			const maxDim = Math.max(size.x, size.y, size.z);
			const scale = 1.5 / maxDim; // фиксированный размер модели
			watch.scale.setScalar(scale);
			watch.position.set(-center.x * scale, -center.y * scale, -center.z * scale);

			scene.add(watch);
		});

		// Анимация
		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			renderer.render(scene, camera);
		}
		animate();

		// Ресайз — только меняем перспективу камеры по ширине
		function onWindowResize() {
			const width = container.clientWidth;
			const height = container.clientHeight;

			// Фиксированное расстояние до модели
			const distance = 2;

			// Ширина модели в сцене (максимальный размер)
			const modelWidth = 1.5; // примерно размер модели после масштабирования

			// Рассчитываем fov по ширине
			const fovRad = 2 * Math.atan((modelWidth / 2) / distance);
			camera.fov = THREE.MathUtils.radToDeg(fovRad);

			// Обновляем аспект
			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
		}

		window.addEventListener('resize', onWindowResize);
	</script>
</body>

</html>