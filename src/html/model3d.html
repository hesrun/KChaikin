<!doctype html>
<html lang="ru">
@include('modules/link.html',{ 'title': 'Main' })

<body>
	@include('modules/header.html',{'theme':'black'})
	<div id="viewer" style="width:100%; height:100vh;">
		<canvas id="scene"></canvas>
	</div>
	<script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
	<script src="https://unpkg.com/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>
	<script src="https://unpkg.com/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
	<script src="https://unpkg.com/three@0.140.0/examples/js/loaders/RGBELoader.js"></script>

	<style>
		#viewer {
			width: 100%;
			height: 100vh;
		}
	</style>



	<script>
		const container = document.getElementById('viewer');
		const canvas = document.getElementById('scene');

		// Сцена
		const scene = new THREE.Scene();

		// Камера
		const camera = new THREE.PerspectiveCamera(65, container.clientWidth / container.clientHeight, 0.1, 1000);
		camera.position.set(0, 0, 2);

		// Рендерер
		const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
		renderer.setSize(container.clientWidth, container.clientHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.outputEncoding = THREE.sRGBEncoding;

		// Контролы — только вращение, без зума
		const controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.enableZoom = false;
		controls.enablePan = false;
		controls.enableDamping = true;

		// HDRI
		const textureLoader = new THREE.TextureLoader();
		textureLoader.load('/static/model/bg.png', function (pngTexture) {
			pngTexture.mapping = THREE.EquirectangularReflectionMapping;

			const pmremGenerator = new THREE.PMREMGenerator(renderer);
			const envMap = pmremGenerator.fromEquirectangular(pngTexture).texture;

			scene.environment = envMap;  // отражения на модели
			// scene.background = envMap; // ← НЕ ставим! Фон будет прозрачным

			pmremGenerator.dispose();
		});

		// Свет

		const ambientLight = new THREE.AmbientLight(0xffffff, 1);
		scene.add(ambientLight);
		const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
		directionalLight.position.set(20, 20, 50);
		scene.add(directionalLight);
		const SpotLight = new THREE.DirectionalLight(0xffffff, 0.6);
		SpotLight.position.set(-50, -50, 100);
		scene.add(SpotLight);


		// Загрузка модели
		const loader = new THREE.GLTFLoader();
		let watch = null;

		loader.load('/static/model/model.glb', function (gltf) {
			watch = gltf.scene;



			// Центрируем и задаём фиксированный размер
			const box = new THREE.Box3().setFromObject(watch);
			const center = box.getCenter(new THREE.Vector3());
			const size = box.getSize(new THREE.Vector3());
			const maxDim = Math.max(size.x, size.y, size.z);
			const scale = 1.5 / maxDim; // фиксированный размер модели
			watch.scale.setScalar(scale);
			watch.position.set(-center.x * scale, -center.y * scale, -center.z * scale);

			scene.add(watch);
		});

		// Анимация
		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			renderer.render(scene, camera);
		}
		animate();

		// Ресайз — только меняем перспективу камеры по ширине
		function onWindowResize() {
			const width = container.clientWidth;
			const height = container.clientHeight;

			// Фиксированное расстояние до модели
			const distance = 2;

			// Ширина модели в сцене (максимальный размер)
			const modelWidth = 1.5; // примерно размер модели после масштабирования

			// Рассчитываем fov по ширине
			const fovRad = 2 * Math.atan((modelWidth / 2) / distance);
			camera.fov = THREE.MathUtils.radToDeg(fovRad);

			// Обновляем аспект
			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
		}

		window.addEventListener('resize', onWindowResize);
	</script>
</body>

</html>